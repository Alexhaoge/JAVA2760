## ThreadDemo.java分析
### 线程的先后顺序
1. compute()的synchronized关键字，确保当前线程的若干次compute连续发生，没有线程切换
2. **线程的优先级具有继承性**,也就是如果线程A启动线程B,那么线程A和B的优先级是一样的,但使用setPriority时无视继承性
3. 没有synchronized时,并不是高优先级的先输出,**优先级较高的线程不一定每一次都先执行完,优先级具有随机性,线程的优先级和打印顺序无关,不能将这两者相关联,它们的关系具有不确定性和随机性**
4. *看起来总是main线程先输出,不管他的优先级或是启动compute的位置,为什么????*
### 运行结果
1. 有synchronize关键字时,在我本机运行时有非常大的概率是这样,不管t1t2的优先级谁高谁低,*为什么????*
>main: 1  
main: 2  
main: 3  
main: 4  
main: 5  
Thread-1: 1  
Thread-1: 2  
Thread-1: 3  
Thread-1: 4  
Thread-0: 1  
Thread-0: 2  
Thread-0: 3  
Thread-0: 4  
2. 去掉synchronized,结果没有确定性，如下是main优先级5，Thread-0优先级10，Thread-1优先级8的一次运行结果
>main: 1  
Thread-1: 1  
Thread-0: 1  
main: 2  
Thread-1: 2  
Thread-1: 3  
Thread-1: 4  
Thread-0: 2  
Thread-0: 3  
main: 3  
Thread-0: 4  
main: 4  
main: 5  