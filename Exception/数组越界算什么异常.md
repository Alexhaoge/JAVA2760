## 数组越界算什么类型的异常
### 1. 就JAVA中exception分类而言，属于runtime exception，因为这个错误的原因是程序写错了  
>划分两个分支的规则是：由程序错误导致的异常属于RuntimeException;而程序本身没有问题，但由于像 I/O 错误这类问题导致的异常属于其他异常。《Java核心技术》  

### 2. 就原理而言属于那种呢？  
（一）课上讨论主要是围绕“是不是操作数越界”。  

操作数：汇编语言指令的一个字段，其实就是一些特定参数，**用这个参数能找到实际需要的数和对象**，操作数包括立即操作数，寄存器操作数（实际数在寄存器里），内存操作数（实际数在内存里），操作码。  
操作数栈：JVM中每个线程中有一个重要的栈——虚拟机栈（用于描述java方法执行的内存模型），栈中结构是一个个**栈帧**，代表一个个方法。栈帧中包含局部变量表、动态链接、返回地址和**操作数栈**。虚拟机把操作数栈作为它的工作区——大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。**所以可以理解操作数栈中存的是计算时候的中间变量。**

那其实JVM操作数栈里这个操作数有可能是个数，也有可能是个地址，因此我觉得**操作数越界是一个大的概念**，如果是立即操作数那就是数字计算的问题，如果是地址那就是寻址的问题，如果是操作码，就可以是某个函数没找到，这些都可以算操作数越界。**毕竟操作数只要CPU在干事就会用到，所以说数组越界是操作数越界也有一定道理，操作栈里存了个数组地址，一看这个数组地址越界了，这内存操作数没找到——操作数越界了嘛。**

（二）另外一个争论是算不算I/O，这里I/O是相对于异常是不是发生在处理器内部而言的。  

**那这就要看多少处理器内是个什么范围了**：如果ALU之外都算处理器外，那这个问题就没有意义了嘛，肯定都是I/O异常，但如果连主存都算内部那又肯不是I/O异常，**所以这里我把处理器的范围划定在CPU，也就是说主存算外部，ALU寄存器cache算内部**，对应到JVM就是**执行引擎程序计数器和栈帧**（说的可能不恰当），这里我说是栈帧而非虚拟机栈，因为运行起来处理器内部只是当前运行的方法而所有方法是存在主存里的。

因此我觉得是不是I/O细究的话要看具体情况了，对于一个方法内的**小数组**它是存在栈帧的局部变量表里的，都是这个栈帧的，**对应到实际运行的时候，有可能这个数组在cache内，那就是处理器内部问题而非I/O了**，毕竟cache都命中了不用调主存；**而如果是个大数组，那就要访问主存了**，这就算作是I/O中出现问题了，**但这也绝不是java意义上的I/O exception**

